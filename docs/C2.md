---
title: "E4 Command and Control (C2) Server Documentation"
author: ["Teserakt AG"]
titlepage: true
# titlepage-waves: true
# titlepage-color: fffff0
titlepage-text-color: 3a3a3c
titlepage-rule-color: ef4a22
logo: branding/logo-text.png 
logo-width: 260
...

# Installation and Configuration

## Prerequisites


## Database configuration

The first step for installing the C2 is to prepare the database 
environment.

### PostgreSQL

These instructions are specific to postgresql, a supported deployment 
option for our C2.

#### Installation and access to the PostgreSQL command line

#### Public Schema

This step is optional, but recommended for C2 deployments. Public 
schema in postgresql databases should not be world-writable. The 
following command revokes all unnecessary privileges:

```
REVOKE ALL PRIVILEGES ON SCHEMA public FROM PUBLIC
```

#### Creating the C2-specific database

We recommend creating a database/role pair `e4` for your E4 specific 
needs. You can do this with the following SQL syntax:

    CREATE ROLE e4 WITH NOSUPERUSER NOCREATEROLE NOINHERIT NOLOGIN NOREPLICATION NOBYPASSRLS;
    CREATE DATABASE e4 WITH OWNER=e4 LC_COLLATE="en_US.UTF-8" LC_CTYPE="en_US.UTF-8" ENCODING=UTF8 TEMPLATE=template0;
    \connect e4;

This creates a database `e4` owned by role `e4`. All C2 instances can 
then live in this database using separate schemas and with separate 
access roles. You can use the role `e4` role to back up and restore 
all C2 instances.

To create a specific schema, run the following:

    CREATE ROLE e4c2_instancename WITH NOSUPERUSER NOCREATEROLE NOINHERIT LOGIN NOREPLICATION NOBYPASSRLS;
    ALTER ROLE e4c2_instancename WITH ENCRYPTED PASSWORD 'yourpassword';
    CREATE SCHEMA IF NOT EXISTS e4c2_instancename AUTHORIZATION e4c2_instancename;
    ALTER ROLE e4c2_instancename SET search_path = e4c2_instancename;
    GRANT ALL ON SCHEMA e4c2_instancename TO e4;

These steps create a role `e4c2_instancename` which can log in to the 
database and connects by default to the database `e4` with access to 
the schema `e4c2_instancename`. If you wish to run multiple C2 
instances in a given database, you can repeat this process for each 
`instancename` giving each its own schema inside the `E4` database.

Script files to do this are available in your C2 installation media 
under `schema/postgres/init.sql`.


#### Configuring Authentication 

In your C2 configuration file you can now configure the chosen 
username and password from the above:

    db-type: postgres
    db-username: e4c2_instancename
    db-password: passwordyouchose
    db-logging: 0

#### Configuring postgresql authentication (without SSL)

You also need to configure your database server correctly 
for access. First, go to `/var/lib/pgsql/data` (this path may 
different for your distribution).

Things are relatively straightforward without SSL. You need to edit 
`pg_hba.conf` to configure user authentication, adding the lines

    
    host    e4     e4c2_instancename    127.0.0.1/32    md5
    host    e4     e4c2_instancename    ::1/128         md5

This allows the role `e4c2_instancename` to log in to database `e4` 
from the local subnet using postgres's double md5 login method.

You can adjust this to your environment; in particular you may wish 
to allow the C2 host and you may wish to use a different 
authentication method if your environment uses directory services, 
for example.

You can then add the following line to your `config.yaml`:

    db-secure-connection: insecure

to your configuration file. Connections will be plaintext over 
port 5432.

#### Configuring postgresql authentication (with SSL)

You need to generate or obtain an X509 certificate/keypair for your 
PostgreSQL server. As part of this process you should be able to 
obtain three files, `server.crt`, `server.key` and `ca.crt` 
containing the X590v3 public certificate (PEM-encoded), the 
PEM-encoded server key and the PEM-encoded CA certificate bundle. 
The process of interacting with a certificate authority, or 
generating your own using on premise PKI, is out of scope of this 
document. Please contact Teserakt AG, or your PKI team, for assistance.

Place all of these in `/var/lib/pgsql/data`. Set their ownership 
to your postgres user and permissions to read only, for example

    chown postgres:postgres server.key
    chmod 0400 server.key

Now edit `postgresql.conf`, either located in this directory or possibly in 
`/etc` and configure these lines:

    ssl = on
    # ssl_ciphers = ... mozilla recommended cipher list ...
    ssl_prefer_server_ciphers = on
    ssl_cert_file = 'server.crt'
    ssl_key_file = 'server.key'
    ssl_ca_file = 'ca.crt'

You will then need to restart the PostgreSQL server. However, before 
you do this, you can edit `pg_hba.conf` as described in the previous 
section, with the following difference:

    
    hostssl    e4     e4c2_instancename    127.0.0.1/32    md5
    hostssl    e4     e4c2_instancename    ::1/128         md5

The main difference is the substitution of `host` for `hostssl`. You 
can now issue

    systemctl restart postgresql

or equivalent on your system.

For your `config.yaml`, if your certificates are self-signed, you 
should add:

    db-secure-connection: selfsigned

Note that other certificate properties (hostname, validity) will still 
be checked.

If your certificate is from a trusted authority or is from internal 
PKI whose root has been added to your system trust store, you can 
use

    db-secure-connection: yes

to enable certificate validation.

### SQLite3 (unsupported in production)

SQLite3 is unsupported in production. However you may wish to use it 
for proof of concept deployments or rapid testing. To configure it, 
in your configuration file set these two options:

    db-type: sqlite3
    db-file: /path/to/e4c2.sqlite

Provided the file is accessible, the C2 will use this database.

### Database security

The last option you should set is a database encryption option. We 
encrypt all key material on its way to the database using a key 
derived from this passphrase. The C2 cannot be started without a valid 
passphrase.

    db-encryption-passphrase: your chosen passphrase

## Installing a broker

We expect that most customers will already have taken these steps. 
For completeness and for customers looking to demo our software 
themselves, the following describes the installation of the broker 
mosquitto.

On linux (redhat systems)

    yum install mosquitto
    systemctl start mosquitto

You can make this run on boot with:

    systemctl enable mosquitto

If you are using macOS (not supported for production deployments) you 
can use brew:

```
brew install mosquitto
mosquitto -c /usr/local/etc/mosquitto/mosquitto.conf
```

## Installing the C2

**TODO TODO TODO**

### Installation using Docker

### Installation using ansible


## Configuring the C2

We assume at this point that you have followed a suitable database 
section from above and have a partially complete `config.yaml` 
containing the appropriate `db-` directives for your database setup.

### Setting the MQTT Broker

The address of the broker can be configured with the

    mqtt-broker: tcp://localhost:1883

In this example `localhost` is used, but you can specify any valid 
host and port, provided it is running an MQTT broker.

The C2 backend, from the point of view of the MQTT network, is simply 
another client. The following option sets its name:

    mqtt-ID: e4c2

Finally, the quality of service option can be configured as follows:

    mqtt-QoS: 2

We recommend the use of QoS level 2 where possible for C2 
communications. However, if your network cannot support this, you can 
downgrade this to `1`. 

### Configuring gRPC API access

The C2 backend uses Google's Protobuf-based RPC (gRPC) libraries 
for use with the c2cli command line client and other product 
interactions. This can be configured as follows:

    grpc-host-port: 0.0.0.0:5555
    grpc-cert: path/to/c2-cert.pem
    grpc-key: path/to/c2-key.pem

These three options expose the IP address and port on which the 
gRPC API endpoint should listen, as well as an SSL certificate and 
SSL private key. 

gRPC uses SSL and cannot be configured without this. However, a 
self signed certificate can be used provided it contains a valid 
common name or subject alternative name for the host.

### Configuring HTTP API access

The HTTP API is configured similarly to gRPC and uses SSL for 
transport layer security. The options are:

    http-host-port: 0.0.0.0:8888
    http-cert: path/to/c2-cert.pem
    http-key: path/to/c2-key.pem

